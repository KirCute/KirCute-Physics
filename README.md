# <center>物理引擎大作业任务报告</center>

这是我们基地纳新的大作业——自写物理引擎，以下是作业报告。

### 开始

​        本次大作业有制作物理引擎和程序改错两个选题，虽然我是蒟蒻，但考虑到我指针学的稀烂，所以只能硬着头皮选择了制作物理引擎这个选题。经考虑后，我首先以制作一个只支持圆形碰撞箱的2D物理引擎为目标，开始了物理引擎的开发。

​        我没能找到一个合适的Java图形库，所以我选择了改用Python开发，使用的图形库是pygame，Python版本是3.9.6。

### 通用部分

​        通用部分用来储存整个开发过程中会用到的数据结构，这部分相关的代码储存在`common.py`中，尽管叫“部分”，但它其实只由`Vector`（也就是二维向量）一个类构成。

###### `Vector`有以下构造方法或工厂方法：

|      | 方法                                 | 说明                                           |
| :--: | :----------------------------------- | ---------------------------------------------- |
|  1   | Vector(x: float = 0., y: float = 0.) | 以给定x, y构造一个二维向量                     |
|  2   | Vector.parse(pos: tuple)             | 将一个二元元组(x, y)转化为二维向量Vector(x, y) |

###### `Vector`有以下公共方法：

|      | 方法                                 | 返回值 | 说明                                                  |
| :--: | ------------------------------------ | ------ | ----------------------------------------------------- |
|  1   | \_\_eq\_\_(other: Vector)            | bool   | 重写==操作，判断向量是否相等                          |
|  2   | \_\_add\_\_(other: Vector)           | Vector | 重写+操作，向量相加                                   |
|  3   | \_\_sub\_\_(other: Vector)           | Vector | 重写-操作，向量相减                                   |
|  4   | \_\_mul\_\_(other: float)            | Vector | 重写\*操作，向量数乘                                  |
|  5   | \_\_truediv\_\_(other: float)        | Vector | 重写/操作，向量数除？                                 |
|  6   | \_\_mod\_\_(other: Vector)           | float  | 虽然是%操作，但这其实是向量点乘                       |
|  7   | \_\_pow\_\_(other: Vector)           | float  | 虽然是\*\*操作，但这其实是向量叉乘                    |
|  8   | \_\_str\_\_()                        | str    | 将向量转化为字符串，用于调试                          |
|  9   | tuple()                              | tuple  | 将一个向量转化为二元元组(x, y)                        |
|  10  | magnitudeSqr()                       | float  | 得到模长平方（速度比得到模长快）                      |
|  11  | magnitude()                          | float  | 得到模长                                              |
|  12  | normalize()                          | Vector | 归一化                                                |
|  13  | opposite()                           | Vector | 反向，得到向量Vector(-x, -y)                          |
|  14  | included(direction: Vector)          | float  | 得到与另一向量的夹角的余弦值                          |
|  15  | decompose(other: Vector)             | Vector | 分解向量，其中一个分向量为other                       |
|  16  | decomposeVertical(direction: Vector) | Vector | 分解向量，两个子向量相互垂直，其中一个与direction同向 |
|  17  | rotate(angle: float)                 | Vector | 得到逆时针旋转angle弧度后的向量                       |
|  18  | overturn()                           | Vector | 翻转向量，得到Vector(y, x)                            |

### 游戏窗口

##### 游戏窗口类（`GameFrame`）

​        游戏窗口类（`GameFrame`）其实不属于物理引擎的一部分，只是出于制作Demo的需要而被封装出来，`GameFrame`负责管理pygame库的初始化，pygame游戏窗体实例的管理，pygame部分事件的处理和游戏周期。`GameFrame`是一个抽象类，每个Demo都需要有它的一个子类来实现相应的游戏功能。

###### 以下方法是需要子类重写的：

|      | 方法                  | 说明                                                      |
| :--: | --------------------- | --------------------------------------------------------- |
|  1   | _init()               | 游戏开始（`start()`被调用后第一帧前）时调用一次           |
|  2   | _exit()               | 游戏结束（`pygame.QUIT`的事件触发后进程结束前）时调用一次 |
|  3   | _update(events: list) | 每帧调用一次，其中`events`参数是该帧的所有事件            |

###### 这些成员变量是子类可以访问到的：

|      | 变量        | 类型           | 说明                                   |
| :--: | ----------- | -------------- | -------------------------------------- |
|  1   | _screen     | pygame.Surface | pygame窗体实例                         |
|  2   | _background | tuple          | 背景色，在每帧渲染前被填充到整个窗口   |
|  3   | _world      | World          | 世界的实例，在这里可以创建新的游戏物品 |

###### 此外，`GameFrame`提供了一些公有方法共其子类或外部调用：

|      | 方法               | 返回值 | 说明                         |
| :--: | ------------------ | ------ | ---------------------------- |
|  1   | setFPS(fps: float) | None   | 设置游戏的最高帧率           |
|  2   | getFPS()           | int    | 得到游戏帧率的整数部分       |
|  3   | start()            | None   | 开始游戏，调用后会进入死循环 |

##### 游戏周期

​        一个游戏周期分为**处理事件，系统更新，物理更新，渲染**几个步骤，这些步骤会依次进行。系统会保证帧率（即1s内游戏周期的数量）低于设定的最大帧率。

​        处理事件时，`pygame.event.get()`将被调用并将返回值保存在一个叫`events`的`list`中，`GameFrame`只会处理类型为`pygame.QUIT`的事件，在触发这一事件时，`GameFrame`会先调用（可能会被子类重写的）`_exit()`方法，之后调用`sys.exit()`退出游戏

​        系统更新步骤中，`GameFrame`只会调用（可能被子类重写的）`_update(events)`方法，其参数就是前文中已经保存的`events`变量。

​        物理更新时，`GameFrame`会调用世界（`self._world`）的`update(screen: tuple)`方法，其参数是`self._screen`的大小，该值会用于判断边缘碰撞情况。在这一步骤中，世界对象会根据力场、碰撞情况和物体自身的速度、加速度更新游戏物体的位置、角度、速度、加速度、角速度等信息，详细说明见*碰撞反馈*部分

​        开始渲染时，`GameFrame`首先会用`self._background`填充整个窗口，随后调用世界（`self._world`）的`render(screen: Surface)`方法，世界会依次调用所有游戏物体的`render(screen: Surface)`方法使他们渲染在游戏窗口中。

### 引擎数据结构

##### 形状（`Shape`）

​        形状描述了一个刚体的形状、大小、颜色等特征，它与刚体所处的世界位置、旋转角度、速度、加速度、角速度总是无关的，因此，**`Shape`中的二维向量总表示局部坐标，且这一局部坐标总以能包含整个形状的最小圆（后称“包盒”）的圆心为原点**。虽然刚体在旋转时的旋转中心应当是重心而不是包盒中心，但考虑到我太弱，所以我将刚体重心和包盒中心视为一点。形状有关的代码储存在`shape.py`中。

###### 形状有以下公共成员：

|      | 变量   | 类型  | 说明       |
| :--: | ------ | ----- | ---------- |
|  1   | radius | float | 包盒的半径 |
|  2   | color  | tuple | 刚体的颜色 |

###### 形状是一个抽象类，其子类必须重写以下抽象方法：

|      | 方法                                                         | 返回值 | 说明                                                         |
| :--: | ------------------------------------------------------------ | ------ | ------------------------------------------------------------ |
|  1   | render(self, screen: pygame.Surface, position: Vector, rotation: float) | None   | 渲染时由刚体调用，其中`position`和`rotation`分别指刚体的世界位置和旋转角度 |

​        其中我所实现的具体形状有圆（`Circle`）和多边形（`Polygon`）两种（尽管我的最初目标中并不打算实现多边形，但出于时间允许，我还是打算进行尝试），其中多边形对形状的拓展最为明显。

​        要构造一个多边形，除了要提供包盒半径以外，还需要提供一个点集（`points`，一个只含有`Vector`的`list`），作为多边形的顶点相对包盒中心的位置。**引擎中的多边形只支持凸多边形**。

###### `Polygon`相比`Shape`多出了以下公共成员：

|      | 变量    | 类型 | 说明                                           |
| :--: | ------- | ---- | ---------------------------------------------- |
|  1   | points  | list | 各顶点相对包盒中心的位置                       |
|  2   | pointsR | list | 相比points在末尾添加了第一个元素，方便两两遍历 |
|  3   | normals | list | 各边远离包盒中心的法向量，用于碰撞检测         |

##### 刚体（`Rigidbody`）

​        刚体是一个具体的游戏物体，它有自己的质量、形状、位置、旋转角度、材质、线速度、角速度。刚体分为一般刚体（`Rigidbody`）和静态刚体（`StaticRigidbody`）两种，后者不会主动更新位置和旋转角度信息，且线速度和角速度总为0。

###### 刚体具有以下公共成员：

|      | 变量            | 类型   | 说明                                                         |
| :--: | --------------- | ------ | ------------------------------------------------------------ |
|  1   | mass            | float  | 刚体的质量                                                   |
|  2   | shape           | Shape  | 刚体的形状                                                   |
|  3   | position        | Vector | 刚体的世界位置                                               |
|  4   | rotation        | float  | 刚体的旋转角度                                               |
|  5   | elasticity      | float  | 刚体的“柔软程度”，在发生碰撞时另一个物体的末速度会与此值相乘，默认为1，即货真价实的物理刚体 |
|  6   | linearVelocity  | Vector | 刚体的线速度                                                 |
|  7   | angularVelocity | float  | 刚体的角速度                                                 |
|  8   | force           | Vector | 刚体的受力情况，在每次update后会清零                         |
|  9   | triggers        | list   | 只含有function，在发生碰撞时全部调用，有两个参数，第一个为刚体自身，第二个为与刚体发生碰撞的另一个刚体，无返回值 |
|  10  | destroyed       | bool   | 被设为True时，刚体会在下一帧被删除                           |

##### 世界（`World`）

​        世界是连接游戏窗口和游戏物体的桥梁，一个游戏只有一个世界对象，世界对象负责储存游戏物体，并启动游戏物体的更新、碰撞检测、渲染流程。

###### 世界含有以下公共成员变量：

|      | 变量       | 类型         | 说明                                                         |
| :--: | ---------- | ------------ | ------------------------------------------------------------ |
|  1   | objs       | list \| Root | 早期版本中使用一个`list`储存刚体对象，后来使用了对象树进行优化，有关内容见*优化*部分 |
|  2   | forceField | list         | 全部力场，力场是一个function，参数为刚体，返回值为一个Vector，表示该刚体在该力场中受到的场力 |

###### 世界含有以下公共成员方法：

|      | 方法                       | 返回值 | 说明                                               |
| :--: | -------------------------- | ------ | -------------------------------------------------- |
|  1   | register(rbody: Rigidbody) | None   | 注册一个新的刚体到objs中                           |
|  2   | update(screen: tuple)      | None   | 世界更新方法，参数为游戏窗体大小，用于判断边缘碰撞 |
|  3   | render(screen: Surface)    | None   | 渲染方法                                           |

### 碰撞检测

​        在完成了刚体位置速度的更新后，首先会对刚体进行两两碰撞检测，对于发生了碰撞的物体，则会马上进行碰撞反馈，这意味着**碰撞检测和碰撞反馈是同时进行的，没有先后之分**，如果一个刚体同时碰撞了两个刚体，那么它会先处理与一方的碰撞，再处理与另一方的碰撞。详细内容见*碰撞反馈*部分。

​        碰撞检测部分的代码位于`contact.py`中，由于碰撞粗测（Broad-Phase）比较简单，以下主要讨论碰撞细测（Narrow-Phase）。

​        注：以下图片均来自网络。

##### 圆-圆碰撞检测

​        圆-圆碰撞粗测与圆-圆碰撞细测算法相同，如果圆-圆碰撞粗测通过，则圆-圆碰撞细测一定通过，由于碰撞检测总是先进行粗测后进行细测，代码中圆-圆碰撞细测方法可以直接返回`True`。以下是碰撞粗测算法。

​        当两圆没有碰撞时，它们圆心之间的距离一定大于两圆半径之和，如图1，必有`f + h < |AC|`：

- <img src="https://github.com/KirCute/KirCute-Physics/blob/master/report/cc_1.png">

​        反之，两圆碰撞时，它们圆心之间的距离一定小于它们的半径之和，如图2，必有`f + h >= |AC|`：

- <img src="https://github.com/KirCute/KirCute-Physics/blob/master/report/cc_2.png">

##### 圆-多边形碰撞检测

​        圆-多边形碰撞检测参考了Box2D引擎的实现方法，首先需要得到多边形各边指向远离包盒中心方向的法向量（即`Polygon.normals`），如图3中的红色向量：

- <img src="https://github.com/KirCute/KirCute-Physics/blob/master/report/cp_3.png">

​        当判断圆与多边形是否碰撞时，计算从多边形各顶点开始到圆形圆心的向量（如图4所示AP、EP），将这些向量与上一步中得到的相应的边法向量（AP对应AF边，AB边的法向量，FE边的法向量对应FP，FP）点乘，结果部分为正部分为负（如图中AP·n<sub>1</sub>为正，EP·n<sub>2</sub>为负），**不难想到离圆形最近的边点乘的结果应当最大，若这个最大值小于圆的半径，则说明多边形与圆足够近，以至于边的一部分已经进入圆中，此时发生碰撞**：

- <img src="https://github.com/KirCute/KirCute-Physics/blob/master/report/cp_4.png">

##### 多边形-多边形碰撞检测

​        多边形相互碰撞检测使用了SAT算法实现。分别取两个多边形各边指向远离包盒中心方向的法向量（即`Polygon.normals`）作为轴，将两个多边形映射在这条轴上，得到轴方向上的两个“区间”。若存在一个轴能够使得两个“区间”不相交，则说明两个多边形没有发生碰撞，否则两多边形相交，图5展示了多边形不碰撞的一个情形，此时使用的轴为五边形的n<sub>1</sub>法向量：

- <img src="https://github.com/KirCute/KirCute-Physics/blob/master/report/pp_5.jpg">

### 碰撞反馈

​        个人认为碰撞反馈是整个物理引擎中最难实现的部分，我在20号从早上10点开始到晚上12点花了足足14个小时，依然没能实现一个较为科学的多边形碰撞反馈，最终我选择使多边形与圆形共用碰撞反馈算法，只额外为多边形附加角速度。

​        在我的引擎中，**碰撞反馈完全使用动量观点实现**，即没有对力的积分计算。这极大的减少了性能（和脑子）上的消耗，但也会不可避免的导致一些问题，比如在两个速度很小的物体碰撞时，速度的改变可能不足以分离二者，又因为要避免二次碰撞，在二者分离前，它们之间都不会再发生碰撞，结果就是在重力的影响下，二者最终合并在一起，除了有外力将他们分离，它们之间将永远不会发生碰撞。

​        碰撞反馈的实现如图6所示，其中圆c，d为两刚体的包盒，矢量u，v为两刚体的速度：

- <img src="https://github.com/KirCute/KirCute-Physics/blob/master/report/impact_6.png">

​        两刚体发生碰撞时，首先会为两刚体施加包盒圆心连线上的两个位移w和a，使得A，C刚好能够分离，位移大小取决于刚体质量，有：
$$
m_As_w + m_Cs_a = 0\\~
s_w + s_a = r_A + r_B - |AC|
$$
​        将两刚体的速度u，v沿圆心连线方向分解，垂直分量记为b，e，共线分量记为m，n，对m，n进行完全弹性碰撞处理得到碰撞后速度分量p，q，有：
$$
m_Av_m + m_Cv_n = m_Av_p + m_Cv_q~\\
\frac{1}{2}m_Av_m^2+\frac{1}{2}m_Cv_n^2=\frac{1}{2}m_Av_p^2+\frac{1}{2}m_Cv_q^2
$$
整理得：
$$
v_p=\frac{(m_A-m_C)v_m+2m_Cv_n}{m_A+m_C}\\~
v_q=\frac{(m_C-m_A)v_n+2m_Av_m}{m_A+m_C}
$$
​        将结果p，q与另一刚体的`elasticity`成员相乘后，再与垂直分量b，e相加，得到A，C的最终速度。**另外，边缘碰撞视为刚体与质量为无穷的物品的碰撞，此时刚体与边缘垂直方向的速度分量刚好反向。**

​        当碰撞双方有多边形时，根据碰撞位置给予其一个角速度。

### 优化

​        考虑到碰撞检测是O(n<sup>2</sup>)算法，而且与多边形有关的碰撞细测算法过于复杂，故必须对其进行优化，优化分为两个方向，一是在进行多边形碰撞检测前，过滤掉明显不可能发生碰撞的情形。二是避免对两个距离极远的刚体进行碰撞检测。前者即在细测之前，先用包盒进行更加快速的粗测，前文中已有论述，**本段主要探讨使用四叉树过滤掉较远刚体的碰撞检测**。

​        四叉树的所有实现均在`quadtree.py`中。

##### 四叉树的数据结构

​        四叉树的实现类可分为两类，节点（`Node`）和节点代理（`Parent`或`NodeProxy`，`Parent`是一个接口，包含子节点访问父节点时所需要用到的所有成员方法，`NodeProxy`在实现了`Parent`的基础上，还额外对接了节点的其它方法，在实际情形中，子节点访问父节点总使用`Parent`，父节点访问子节点总使用`NodeProxy`，之所以需要`Parent`是因为父节点访问子节点时，子节点一定是一个完善的节点，而子节点访问父节点时却不能保证这一点，比如根节点通过访问伪父节点`Entrance`实现遍历的结束），其中节点与节点一一对应，一个节点的**唯一**实例总是由节点代理保管。节点又分为枝节点（`Branch`）和叶节点（`Leaf`），其中叶节点只保管一部分刚体，枝节点除了保管部分刚体外，还可以访问子节点的节点代理。每个节点所需要管理的刚体都能对应到屏幕上的某个区域，每个节点管理的刚体所在的范围是都一个标准矩形，**其中叶节点管理的节点都保存在自身的`_storage`成员列表中，枝节点会尽可能的将自身管理的刚体放在子节点中，除非刚体位于子节点管理范围的边界上，无法被放入任何子节点。**你一定会很疑惑为什么要使用节点代理，下面马上会讲到。

###### 叶节点拥有以下成员变量：

|      | 变量     | 类型      | 说明                                               |
| :--: | -------- | --------- | -------------------------------------------------- |
|  1   | _parent  | Parent    | 父节点                                             |
|  2   | _proxy   | NodeProxy | 与自身对应的节点代理                               |
|  3   | _layer   | int       | 自身所在层数                                       |
|  4   | _start   | tuple     | 自身管理范围左上角的坐标                           |
|  5   | _end     | tuple     | 自身管理范围右下角的坐标                           |
|  6   | _storage | list      | 自身正在管理的游戏物体（不含子节点正在管理的物体） |

###### 枝节点相比叶节点多出了以下成员变量：

|      | 变量 | 类型      | 说明                     |
| :--: | ---- | --------- | ------------------------ |
|  1   | _lu  | NodeProxy | 位于左上方的节点（代理） |
|  2   | _ru  | NodeProxy | 位于右上方的节点（代理） |
|  3   | _ld  | NodeProxy | 位于左下方的节点（代理） |
|  4   | _rd  | NodeProxy | 位于右下方的节点（代理） |

##### 四叉树的延伸

​        **当一个叶节点管理的刚体数量超过`DivideCount`（默认为5）个且自身所在层数小于`MaxLayer`（默认为3）层时，该叶节点会尝试延伸。**具体的操作方法是，叶节点首先会访问自身的节点代理，使其重新指向一个与自身管理范围相同的枝节点（枝节点在构造时就会将管理区域划分为4块并交给4个子叶节点保管），并将全部由自身管理的刚体交由新的枝节点管理，由于节点代理保存有节点的唯一引用，该叶节点在完成延伸后会被gc清除，而对于该节点的父节点来说，**由于该节点的父节点保存的是对节点代理的引用，而在这一过程中节点代理并没有变化，只是与其对应的节点发生了变化，因而父节点可以照旧的访问该子节点（此时已成为枝节点）。**如果不使用节点代理的设计，那么子节点就必须访问父节点来进行枝-叶替换工作，而父节点保留有4个节点，无法判断发出延伸申请的是哪个节点，这一设计很好的避免了这一问题，使得子节点的延伸工作可以脱离父节点而进行。

##### 四叉树的遍历

​        节点入口（`Entrance`）是一种特殊的节点代理，它不指向任何节点，它保管一个节点代理，且作为该节点代理所对应节点（以下称根节点）的父节点。节点入口在构造时就会同步构造其子节点（也就是根节点）。

​		世界（`World`）通过访问节点入口实现四叉树遍历的开始，在每一帧中，四叉树要进行三项工作，**更新所有刚体，检查刚体是否进入父节点或子节点（若是则对刚体进行升降级），碰撞检测和反馈**。

###### 刚体更新

​        刚体的更新由节点入口发起，每个枝节点先更新自己管理的刚体，再对其子节点进行“深度优先更新”，直至所有节点的`update(force: list)`方法均被调用一遍。

###### 刚体升降级检查

​        刚体升降级检查由节点入口发起，每个枝节点先尝试升级（即将自身管理的刚体交由**子**节点管理）自身管理的刚体，在对子节点DPS，再检查是否有需要降级（即将自身管理的刚体交由**父**节点管理）的刚体并进行降级。**当遇到刚体连升多级时，由于枝节点先升级后DPS子节点，该刚体能在一次遍历中升级到位，当遇到刚体连降多级时，由于枝节点先DPS子节点后降级，该刚体同样能在一次遍历中降级到位。**叶节点的延伸也在此步骤进行。当一个刚体被根节点降级时（此时该刚体已离开屏幕），该刚体将被根节点降级进节点入口，但因为节点入口不保留任何刚体，该刚体将会因为丢失引用而等待gc回收。

###### 碰撞检测和反馈

​      **节点入口总是先发起刚体-刚体碰撞检查，后发起刚体-边缘碰撞检查。**刚体-边缘碰撞检查的过程与刚体更新类似，任意节点进行刚体-刚体碰撞检查时，总是先对自身管理的刚体进行两两碰撞检查，再向父节点发起碰撞检查申请，检查每个刚体是否与父节点中的某个刚体发生碰撞。**父节点在接到碰撞检查申请后，除了检查该刚体是否与其管理的刚体是否碰撞以外，还会向祖父节点传递碰撞检查申请，直到根节点向节点入口发送碰撞检查申请时，由于节点入口的碰撞检查不执行任何语句，本次碰撞检查宣告结束。**

###### 以上功能由下列方法实现：

|      | 方法                      | 说明                                                         |
| :--: | ------------------------- | ------------------------------------------------------------ |
|  1   | rebuild(node: Node)       | （该方法只存在于节点代理中）由叶节点调用，使节点代理指向一个新的枝节点 |
|  2   | insert(rbody: Rigidbody)  | 使一个刚体交由自身管理（升级时父节点调用子节点的该方法，降级时子节点调用父节点的该方法 |
|  3   | update(force: list)       | (DPS)刚体更新                                                |
|  4   | check()                   | (DPS)刚体升降级检查                                          |
|  5   | collideCheck()            | (DPS)刚体碰撞检测和反馈                                      |
|  6   | collide(rbody: Rigidbody) | 由子节点在`collideCheck()`中调用，检查一个刚体是否与父（祖父、祖祖父、……、根节点）中的某个刚体发生碰撞 |
|  7   | solveEdge(screen: tuple)  | (DPS)边缘碰撞检查                                            |

##### 使用四叉树进行优化的效果

​        使用四叉树进行优化效果明显。经过实测（使用quadtree_demo，设备：联想r7000 3050版，省电模式），在不使用四叉树时，同屏有80个刚体（均为半径为10的小球）时帧数大约为40，而在使用四叉树时，使游戏帧率降低至40，同屏则有约130个刚体。在不使用四叉树时，同屏有130个刚体时帧数大约为15，而在使用四叉树时，使游戏帧率降低至15，同屏则有约220个刚体。

### 结束语

* 就是不给你看。

